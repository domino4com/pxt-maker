# cloudbuild.yaml â€” ESP32-S2 only, fast staticpkg + Firebase deploy

timeout: "3600s"   # 60 minutes max (should finish well before this)

substitutions:
  _FIREBASE_PROJECT: "springbot-co-za"
  _FIREBASE_SITE: "springbot-co-za"
  _REPO_PXT: "https://github.com/domino4com/pxt.git"
  _REPO_PKGS: "https://github.com/domino4com/pxt-common-packages.git"

options:
  logging: CLOUD_LOGGING_ONLY
  machineType: E2_HIGHCPU_8

steps:
  # 0) Clone pxt
  - id: "Clone pxt"
    name: gcr.io/cloud-builders/git
    entrypoint: bash
    args:
      - -lc
      - |
        git clone "${_REPO_PXT}" pxt

  # 1) Clone pxt-common-packages
  - id: "Clone pxt-common-packages"
    name: gcr.io/cloud-builders/git
    entrypoint: bash
    args:
      - -lc
      - |
        git clone "${_REPO_PKGS}" pxt-common-packages

  # 2) Prune to ESP32-S2 only & prep workspace
  - id: "Prune to ESP32-S2"
    name: node:18
    entrypoint: bash
    args:
      - -lc
      - |
        set -euxo pipefail
        # Prune libs to ESP32-S2
        chmod +x scripts/prune-for-esp32s2.sh || true
        ./scripts/prune-for-esp32s2.sh

        # Make sure Node modules start clean at the root
        rm -rf node_modules package-lock.json || true
        rm -rf pxt/node_modules pxt-common-packages/node_modules || true

  # 3) Install target deps WITHOUT running lifecycle scripts (no CRA subapps)
  - id: "Install target deps (no scripts)"
    name: node:18
    entrypoint: bash
    args:
      - -lc
      - |
        set -euxo pipefail
        npm config set fund false
        npm config set audit false
        # Install deps for this target only; don't run prepare/postinstall from pxt-core subapps
        npm install --ignore-scripts

  # 4) Link local pxt + pxt-common-packages
  - id: "Link local pxt repos"
    name: node:18
    entrypoint: bash
    args:
      - -lc
      - |
        set -euxo pipefail
        # Use pxt CLI v0.5.1 and link local checkouts
        npx --yes pxt@0.5.1 link ./pxt
        npx --yes pxt@0.5.1 link ./pxt-common-packages

  # 5) Build static package (no extra flags; v0.5.1 rejects --out/--noMini)
  - id: "Build static package"
    name: node:18
    entrypoint: bash
    args:
      - -lc
      - |
        set -euxo pipefail
        # Build static site for the target
        npx --yes pxt@0.5.1 staticpkg

        # Determine where staticpkg wrote files (varies by PXT version/target)
        SRC=""
        if [ -d "docs" ]; then
          SRC="docs"
        elif [ -d "built/packaged" ]; then
          SRC="built/packaged"
        elif [ -d "built/packaged/packaged" ]; then
          SRC="built/packaged/packaged"
        else
          echo "Could not find staticpkg output. Checked: docs, built/packaged[/packaged]." >&2
          exit 2
        fi

        # Prepare hosting directory
        rm -rf hosting
        mkdir -p hosting
        cp -a "${SRC}/." hosting/

        # Create minimal Firebase Hosting config (targets the default site)
        cat > firebase.json <<'JSON'
        {
          "hosting": {
            "public": "hosting",
            "ignore": ["firebase.json", "**/.*", "**/node_modules/**"]
          }
        }
        JSON

        cat > .firebaserc <<JSON
        {
          "projects": { "default": "${_FIREBASE_PROJECT}" }
        }
        JSON

  # 6) Deploy to Firebase Hosting (default site)
  - id: "Deploy to Firebase Hosting"
    name: gcr.io/firebase-public/firebase
    entrypoint: bash
    args:
      - -lc
      - |
        set -euxo pipefail
        # Ensure the site exists and is the one we want to deploy to.
        # (No-op if it already exists.)
        firebase hosting:sites:list --project "${_FIREBASE_PROJECT}" >/dev/null 2>&1 || true

        # Deploy using firebase.json (public=hosting) to the default project.
        # Since firebase.json doesn't specify 'site', we pass --site to pin it.
        firebase deploy \
          --project "${_FIREBASE_PROJECT}" \
          --only hosting \
          --site "${_FIREBASE_SITE}"
