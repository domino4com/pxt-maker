timeout: "1200s"  # 20 minutes

options:
  logging: CLOUD_LOGGING_ONLY
  machineType: E2_HIGHCPU_8
  substitution_option: ALLOW_LOOSE

substitutions:
  _REPO_PXT: https://github.com/domino4com/pxt.git
  _REPO_PKGS: https://github.com/domino4com/pxt-common-packages.git
  _FIREBASE_PROJECT: springbot-co-za
  _FIREBASE_SITE: springbot-co-za
  # "false" => use IAM (service account perms). "true" => use FIREBASE_TOKEN secret.
  _USE_FIREBASE_TOKEN: "false"
  # Secret Manager version to use when _USE_FIREBASE_TOKEN="true"
  _FIREBASE_TOKEN_SECRET: projects/springbot-co-za/secrets/FIREBASE_TOKEN/versions/latest

availableSecrets:
  secretManager:
    - versionName: ${_FIREBASE_TOKEN_SECRET}
      env: FIREBASE_TOKEN

steps:
  # 0) Clone PXT (parallel)
  - name: gcr.io/cloud-builders/git
    id: Clone pxt
    waitFor: ["-"]
    entrypoint: bash
    args: ["-lc", "set -euo pipefail; git clone \"$_REPO_PXT\" pxt"]

  # 1) Clone common packages (parallel)
  - name: gcr.io/cloud-builders/git
    id: Clone pxt-common-packages
    waitFor: ["-"]
    entrypoint: bash
    args: ["-lc", "set -euo pipefail; git clone \"$_REPO_PKGS\" pxt-common-packages"]

  # 2) Prune to ESP32-S2 (depends on both clones)
  - name: node:18
    id: Prune to ESP32-S2
    waitFor: ["Clone pxt", "Clone pxt-common-packages"]
    entrypoint: bash
    args:
      - -lc
      - |
        set -euo pipefail
        chmod +x scripts/prune-for-esp32s2.sh
        ./scripts/prune-for-esp32s2.sh

  # 2.5) Pin target to ESP32-S2 only (NOW scans node_modules/*/pxttarget.json first)
  - name: node:18
    id: Pin target to ESP32-S2 only
    waitFor: ["Prune to ESP32-S2"]
    entrypoint: bash
    args:
      - -lc
      - |
        set -euo pipefail
        node - <<'NODE'
        const fs = require('fs');
        const path = require('path');

        function exists(p) { try { fs.accessSync(p); return true; } catch { return false; } }
        function glob1(dir, filename) {
          if (!exists(dir)) return null;
          for (const ent of fs.readdirSync(dir, { withFileTypes: true })) {
            if (ent.isDirectory()) {
              const cand = path.join(dir, ent.name, filename);
              if (exists(cand)) return cand;
            }
          }
          return null;
        }
        function firstExisting() {
          // Look in node_modules first (this is where Maker target usually lives)
          const nm = glob1('node_modules', 'pxttarget.json');
          if (nm) return nm;
          // Then the workspace
          if (exists('pxttarget.json')) return 'pxttarget.json';
          const targetsDir = 'targets';
          if (exists(targetsDir)) {
            for (const ent of fs.readdirSync(targetsDir, { withFileTypes: true })) {
              if (ent.isDirectory()) {
                const cand = path.join(targetsDir, ent.name, 'pxttarget.json');
                if (exists(cand)) return cand;
              }
            }
          }
          // And finally the cloned pxt repo (rare)
          if (exists('pxt/pxttarget.json')) return 'pxt/pxttarget.json';
          return null;
        }

        const found = firstExisting();
        if (!found) {
          console.log('No pxttarget.json found anywhere; skipping variant pin.');
          process.exit(0);
        }

        console.log(`Pinning variants in ${found} to ["esp32s2"]`);
        const j = JSON.parse(fs.readFileSync(found, 'utf8'));
        const only = ['esp32s2'];
        const setOnly = (o, k) => { if (o && Object.prototype.hasOwnProperty.call(o, k)) o[k] = only; };
        setOnly(j, 'variants');
        setOnly(j, 'compileServiceVariants');
        setOnly(j, 'platforms');
        setOnly(j, 'hardwareVariants');
        if (j.sim && j.sim.hardwareVariants) j.sim.hardwareVariants = only;
        fs.writeFileSync(found, JSON.stringify(j, null, 2));
        console.log('Result:\n' + fs.readFileSync(found, 'utf8'));
        NODE

  # 3) Install deps (no scripts) + purge Node types (depends on pin)
  - name: node:18
    id: Install deps (no scripts) + purge node types
    waitFor: ["Pin target to ESP32-S2 only"]
    entrypoint: bash
    args:
      - -lc
      - |
        set -euo pipefail
        npm config set fund false
        npm config set audit false
        npm ci --ignore-scripts || npm install --ignore-scripts
        rm -rf node_modules/@types/node \
               pxt/node_modules/@types/node \
               pxt-common-packages/node_modules/@types/node || true

  # 4) Stage libs (depends on install)
  - name: node:18
    id: Stage libs
    waitFor: ["Install deps (no scripts) + purge node types"]
    entrypoint: bash
    args:
      - -lc
      - |
        set -euo pipefail
        rm -rf libs
        ln -s /workspace/pxt-common-packages/libs ./libs
        [ -d libs/base---light ] || cp -a libs/base libs/base---light


  # 4.5) Shim STM32 transforms to ESP32(S2) to stop PXT from chdir'ing to non-existent libs
  - name: node:18
    id: Shim stm32 transforms
    waitFor: ["Stage libs"]
    entrypoint: bash
    args:
      - -lc
      - |
        set -euo pipefail
        cd /workspace/libs
        # Prefer esp32s2 fallbacks; if not available, fall back to esp32; else to base lib
        link_fallback() {
          local name="$1"
          local target=""
          if [ -d "${name}---esp32s2" ]; then target="${name}---esp32s2";
          elif [ -d "${name}---esp32" ]; then target="${name}---esp32";
          elif [ -d "${name}" ]; then target="${name}";
          else return 0; fi
          if [ ! -e "${name}---stm32" ]; then
            ln -s "${target}" "${name}---stm32"
            echo "shim: ${name}---stm32 -> ${target}"
          fi
        }
        # Common libs PXT tries to variant-map; extend if errors mention others
        for lib in core settings screen serial power display; do
          link_fallback "$lib"
        done      

  # 5) Build static package (depends on stage)
  - name: node:18
    id: Build static package
    waitFor: ["Stage libs"]
    entrypoint: bash
    args:
      - -lc
      - |
        set -euo pipefail
        echo "Resolved target file (if any):"
        ls -1 node_modules/*/pxttarget.json 2>/dev/null || true
        # Limit to avoid rare hangs
        PXT_NOSIM=1 timeout 15m npx --yes pxt@0.5.1 staticpkg

  # 6a) Deploy via IAM (default; skips if _USE_FIREBASE_TOKEN="true")
  - name: gcr.io/cloud-builders/gcloud
    id: Firebase deploy (IAM)
    waitFor: ["Build static package"]
    entrypoint: bash
    args:
      - -lc
      - |
        set -euo pipefail
        if [ "${_USE_FIREBASE_TOKEN}" = "true" ]; then
          echo "Skipping IAM deploy because _USE_FIREBASE_TOKEN=true"
          exit 0
        fi
        curl -sL https://firebase.tools | bash
        firebase deploy \
          --only "hosting:${_FIREBASE_SITE}" \
          --project "${_FIREBASE_PROJECT}" \
          --non-interactive

  # 6b) Deploy via FIREBASE_TOKEN secret (runs but no-ops unless _USE_FIREBASE_TOKEN="true")
  - name: gcr.io/cloud-builders/gcloud
    id: Firebase deploy (token)
    waitFor: ["Build static package"]
    entrypoint: bash
    secretEnv: ["FIREBASE_TOKEN"]
    args:
      - -lc
      - |
        set -euo pipefail
        if [ "${_USE_FIREBASE_TOKEN}" != "true" ]; then
          echo "Skipping token deploy because _USE_FIREBASE_TOKEN!=true"
          exit 0
        fi
        : "$${FIREBASE_TOKEN:?FIREBASE_TOKEN secret not provided}"
        curl -sL https://firebase.tools | bash
        firebase deploy \
          --only "hosting:${_FIREBASE_SITE}" \
          --project "${_FIREBASE_PROJECT}" \
          --non-interactive \
          --token "$$FIREBASE_TOKEN"
